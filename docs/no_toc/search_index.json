[["index.html", "04: Version Control About this Course", " 04: Version Control March, 2023 About this Course This course is part of a series of courses for DataTrail. DataTrail is a no-cost, paid 14-week educational initiative for young-adult, high school and GED-graduates. DataTrail aims to equip members of underserved communities with the necessary skills and support required to work in the booming field of data science. DataTrail is a fresh take on workforce development that focuses on training both Black, Indigenous, and other people of color (BIPOC) interested in the data science industry and their potential employers. Offered by the Johns Hopkins Bloomberg School of Public Health, in partnership with local non-profits and Leanpub, DataTrail combines a mutually-intensive learning experience (MILE) with a whole-person ecosystem of support to allow aspiring data scientists and their employers to succeed. DataTrail uses mutually-intensive learning DataTrail joins aspiring data science scholars and expert-level data scientist mentors in a mutually-intensive learning experience (MILE). In the DataTrail MILE: Scholars engage in cutting-edge technical and soft skills training needed to enter the data science field. Mentors engage in anti-racism and mentorship training needed to be impactful mentors and informed colleagues on diverse data science teams. The social connections created along the way will fuel job opportunities for scholars and foster a more diverse, equitable, and inclusive climate at the mentors’ institutions. "],["version-control.html", "Chapter 1 Version Control", " Chapter 1 Version Control In this lesson, we’ll give you a basic understanding of version control. We’ll look at what version control is, some of its benefits, and give an introduction to Git and GitHub, the main way you will interface with version control systems in these courses. 1.0.1 What is version control? One common mantra from data analysis and writing code is “save early, save often”. What is meant by this is that you do not want to create content without saving it frequently. This way, if you lose your internet connection, or your computer crashes, you will not lose the hard work you have put in. On the other hand, sometimes we create some content, only to realize that it is not what we want, and we want to undo the changes we have just made. Version control allows us to save frequently, while also taking snapshots of our work at any point in time, allowing us to go back to a previous version if necessary. A good version control system will do this without you having to save multiple copies of your work (avoiding having “myFile_version1”, “myFile_version2”, etc. saved to your computer) or having to keep track of what the latest version of the file is. If you’ve ever used the “Track changes” feature in Microsoft Word, you have seen a rudimentary type of version control, in which the changes to a file are tracked, and you can either chose to keep those edits or revert to the original format. Version control systems, like Git, can be thought of as a more sophisticated “Track changes” - in that they are far more powerful and are capable of meticulously tracking successive changes on many files, with potentially many people working on the same groups of files at the same time. If you’ve ever worked collaboratively on a document before, this comic from PHD Comics might resonate with you. Hopefully, once you’ve mastered version control software, Paper_Final_FINAL2_actually_FINAL.docx will be a thing of the past for you! 1.0.2 Version control on your own As mentioned above, even if you are the only one working on a project, saving frequently and preserving snapshots of your work at a specific time prevents you from losing work or making changes that cause the work you have already done to not work anymore. Or, you might be keeping multiple, very similar, copies of a file. And this could be dangerous - you might start editing the wrong version, not recognizing that the document labelled “FINAL” has been further edited to “FINAL2” - and now all your new changes have been applied to the wrong file! Version control systems help to solve this problem by keeping a single, updated version of each file, with a record of all previous versions AND a record of exactly what changed between the versions. 1.0.3 Version control for collaboration or sharing One advantage of using version control for your projects is that multiple users can work on different parts of the same project at the same time. Each individual can edit different files that make up a project simultaneously, and all the results can be saved in the same place. Two (or more) individuals can even work on editing the same file simultaneously, and a good version control system will allow them to then resolve any differences between the two file versions that result. Additionally, since version control systems keep a record of all changes made to the files, this can be of great help when you are collaborating with many people on the same files - the version control software keeps track of who, when, and why those specific changes were made. It’s like “Track changes” to the extreme! 1.0.4 Summarizing the benefits of version control systems It gives you an easy way of saving a backup of your work as you go, making sure you don’t lose anything you have created. It allows you to go back to an earlier version of your work if something gets broken due to the changes you have made. It allows multiple people to edit code at the same time, without worrying that what they’re doing might be messing someone else’s code up. 1.0.5 What is Git? Why should you use it? In this course, we will introduce version control software called Git. Git is a free and open source version control system. It was developed in 2005 and has since become the most commonly used version control system around! StackOverflow surveyed over 60,000 respondents on which version control system they use, and as you can tell from the chart below, Git is by far the winner. Git is far and away the most commonly used version control system according to StackOverflow As you become more familiar with Git and how it works and interfaces with your projects, you’ll begin to see why it has risen to the height of popularity. One of the main benefits of Git is that it keeps a local copy of your work and revisions, which you can then edit offline, and then once you return to internet service, you can sync your copy of the work, with all of your new edits and tracked changes to the main repository online. And since Git is automatically taking these snapshots, there is no need for you to save your own copy with different versions or different dates. Additionally, since all collaborators on a project have their own local copy of the code, everybody can simultaneously work on their own parts of the code, without disturbing that common repository. Another big benefit that we’ll definitely be taking advantage of is the ease with which RStudio and Git interface with each other. 1.0.6 What is GitHub? GitHub is a website that provides an interface to a cloud-based repository management system. In other words, GitHub is an online interface for Git. Git is software used locally on your computer to record changes. GitHub is a host for your files and the records of the changes made. You can sort of think of it as being similar to DropBox - the files are on your computer, but they are also hosted online and are accessible from any computer. GitHub has the added benefit of interfacing with Git to keep track of all of your file versions and changes. Another way of thinking of it is as a big room with lots of large filing cabinets. Each filing cabinet contains the files associated with a particular project. These files have been created and are being edited by one or more people who have access to that particular filing cabinet or repository. GitHub allows you to control who can see and access your files. GitHub uses the version control system Git, described above, to manage version control, and provides users with a web-based interface for creating projects, sharing them, updating code, etc. In this course, we will be teaching you how to do version control using GitHub. We will introduce you to the basics of working with GitHub, both through your browser and through RStudio. For our purposes, you will not need to think about Git itself, and will instead just use GitHub. 1.0.7 Version control vocabulary There is a lot of vocabulary involved in working with Git, and often the understanding of one word relies on your understanding of a different Git concept. Take some time to familiarize yourself with the words below and read over it a few times to see how the concepts relate. Repository: Equivalent to the project’s folder/directory - all of your version controlled files (and the recorded changes) are located in a repository. This is often shortened to repo. Repositories are what are hosted on GitHub and through this interface you can either keep your repositories private and share them with select collaborators, or you can make them public - anybody can see your files and their history. Commit: To commit is to save your edits and the changes made. A commit is like a snapshot of your files. Git compares the previous version of all of your files in the repo to the current version and identifies those that have changed since then. For those that have not changed, Git maintains that previously stored file, leaving it untouched. For those that have changed, Git compares the files, logs the changes and uploads the new version of your file to GitHub. We’ll touch on this in the next section, but when you commit a file, typically you accompany that file change with a little note about what you changed and why. When we talk about version control systems, commits are at the heart of them. If you find a mistake, you revert your files to a previous commit. If you want to see what has changed in a file over, you compare the commits and look at the messages to see why the changes were made and who made them. Push: Updating the repository with your edits. Since Git involves making changes locally, you need to be able to share your changes with the common, online, repository. Pushing is sending those committed changes to that repository, so now everybody has access to your edits. Pull: Updating your local version of the repository to the current version, since others may have edited in the meanwhile. Because the shared repository is hosted online and any of your collaborators (or even yourself on a different computer!) could have made changes to the files and then pushed them to the shared repository, you are behind the times! The files you have locally on your computer may be outdated, so you pull to check if you are up to date with the main repository. Staging: The act of preparing a file for a commit. For example, if since your last commit you have edited three files for completely different reasons, you don’t want to commit all of the changes in one go, or your message on why you are making the commit and what has changed will be complicated, since three files have been changed for different reasons. So instead, you can stage just one of the files and prepare it for committing. Once you’ve committed that file, you can stage the second file and commit it. And so on. Staging allows you to separate out file changes into separate commits. Very helpful! To summarize these commonly used terms so far and to test whether you’ve got the hang of this, files are hosted in a repository that is shared online with collaborators. You pull the repository’s contents so that you have a local copy of the files that you can edit. Once you are happy with your changes to a file, you stage the file and then commit it. You push this commit to the shared repository. This uploads your new file and all of the changes and is accompanied by a message explaining what changed, why and by whom. Visual representation summarizing repository, commit, push, and pull Branch: When the same file has two simultaneous copies. When you are working locally and editing a file, you have created a branch where your edits are not shared with the main repository (yet) - so there are two versions of the file: the version that everybody has access to on the repository and your local edited version of the file. Until you push your changes and merge them back into the main repository, you are working on a branch. Following a branch point, the version history splits into two and tracks the independent changes made to both the original file in the repository that others may be editing, and tracking your changes on your branch, and then merges the files together. Merge: Independent edits of the same file are incorporated into a single, unified file. Independent edits are identified by Git and are brought together into a single file, with both sets of edits incorporated. But, you can see a potential problem here! If both people made an edit to the same sentence that precludes one of the edits from being possible, we have a problem! Git recognizes this disparity (conflict) and asks for user assistance in picking which edit to keep. Conflict: When multiple people make changes to the same file and Git is unable to merge the edits. You are presented with the option to manually try and merge the edits or to keep one edit over the other. A visual representation of these concepts, from https://www.atlassian.com/git/tutorials/using-branches/git-merge Clone: Making a copy of an existing Git repository. If you have just been brought on to a project that has been tracked with version control, you would clone the repository to get access to and create a local version of all of the repository’s files and all of the tracked changes. Fork: A personal copy of a repository that you have taken from another person. If somebody is working on a cool project and you want to play around with it, you can fork their repository and then when you make changes, the edits are logged on your repository, not theirs. 1.0.8 Best practices It can take some time to get used to working with version control software like Git, but there are a few things to keep in mind to help establish good habits that will help you out in the future. One of those things is to make purposeful commits. Each commit should only address a single issue. This way if you need to identify when you changed a certain line of code, there is only one place to look to identify the change and you can easily see how to revert the code. Similarly, making sure you write informative messages on each commit is a helpful habit to get into. If each message is precise in what was being changed, anybody can examine the committed file and identify the purpose for your change. For example, if you edited your code to use a new dataset, an informative commit message may be “updated file to use dataset from www.wheredatacamefrom.com.” On the other hand, an unhelpful commit messaged would be “data” or “update.” These types of commit messages are to be avoided. Further, by using helpful commit messages, if you are looking for a specific edit you made in the past, you can easily scan through all of your commits to identify those changes related to the desired edit. You don’t want to get in the same habit that xkcd has! Finally, be cognizant of the version of files you are working on. Check that you are up to date with the current repo by frequently pulling. Additionally, don’t hoard your edited files - once you have committed your files (and written that helpful message!), you should push those changes to the common repository. If you are done editing a section of code and are planning on moving on to an unrelated problem, you need to share that edit with your collaborators! 1.0.9 Summary Now that we’ve covered what version control is and some of the benefits, you should be able to understand why we have an entire course dedicated to understanding it! Additionally, we looked at what Git and GitHub are, and then covered much of the commonly used (and sometimes confusing!) vocabulary inherent to version control work. We then quickly went over some best practices to using Git – but the best way to get a hang of this all is to use it! Hopefully you feel like you have a better handle on how Git works than the people in this xkcd comic! 1.0.10 Slides and video Automated Video Slides "],["github.html", "Chapter 2 GitHub", " Chapter 2 GitHub Now that we have a handle on what version control is and how we can interface with it, we’ll take some time to look at GitHub and get familiar with their website. As we previously learned, GitHub is a cloud-based management system for your version controlled files. Like DropBox, your files are both locally on your computer and hosted online and easily accessible. Its interface allows you to manage version control and provides users with a web-based interface for creating projects, sharing them, updating code, etc. 2.0.1 Logging in to GitHub In the introductory course, you learned how to create a GitHub account. Use your account username and password to log in to GitHub. To log in, go to https://github.com/, where you will be presented with the homepage. If you aren’t already logged in, click on the “Sign in” link at the top. GitHub’s homepage at https://github.com/ Once you’ve done that, you will see the log in page where you will enter in your username and password that you created in the first course in this series. GitHub’s log in page Once logged in, you will be back at https://github.com/, but this time the screen should look like this: If you are logged in, GitHub should look like this 2.0.2 The Homepage We’re going to take a quick tour of the GitHub website, and we’ll particularly focus on these sections of the interface: User settings Notifications Help files The GitHub guide Following this tour, we’ll make your very first repository using the GitHub guide! Some major features of GitHub 2.0.3 User Settings Now that you’ve logged on to GitHub, we should fill out some of your profile information and get acquainted with the account settings. In the upper right corner, there is a an icon with an arrow beside it, click this and go to “Your profile” Where to find user settings This is where you control your account from and can view your contribution histories and repositories. Where to find user settings Since you are just starting out, you aren’t going to have any repositories or contributions yet - but hopefully we’ll change that soon enough! What we can do right now is edit your profile. To orient you a bit, the Overview tab provides a summary of your work on GitHub. You can showcase up to 6 of your repositories by clicking the link labeled “Customize your pinned repositories.” When you are logged into GitHub, the Repositories tab lists all public and private repositories you have. If your are not logged in, it will only show your public repositories. The Stars tab shows repositories you have starred, similar to bookmarking a web page in your browser. If you find the contents of a repository interesting, you can go to the main repository page and click the Star button near the top right. The Followers and Following tabs shows users that you follow and who follow you for activity updates. Following others is is a nice way to explore other people’s work. Go to “Edit profile” along the lefthand edge of the page. Here, take some time and fill out your name and a little description of yourself in the “Bio” box, and if you like, upload a picture of yourself! When you are done, click “Update profile” Your profile page Along the lefthand side of this page, there are many options for you to explore. Click through each of these menus to get familiar with the options available to you. To get you started, go to the account page. Your account page Here, you can edit your password or if you are unhappy with your username, change it. Be careful though, there can be unintended consequences when you change your username - if you are just starting out and don’t have any content yet, you’ll probably be safe though. The Account tab lets you change your username or password. The Emails tab lets you modify what e-mail address(es) to use for notifications and has some privacy settings relating to where your e-mail addresses can appear publicly. The Notifications tab allows you to fine tune what GitHub updates send notifications and where they are sent. Continue looking through the rest of the personal setting options on your own. When you are done, go back to your profile. Once you’ve had a bit more experience with GitHub, you’ll eventually end up with some repositories to your name. To find those, click on the “Repositories” link on your profile. For now, it will probably look like this: Your repositories page 2.0.4 Notifications Next, we’ll check out the notifications menu. Along the menu bar across the top of your window, there is a bell icon, representing your notifications. Click on the bell. Your notifications Once you become more active on GitHub and are collaborating with others, here is where you can find messages and notifications for all the repositories, teams, and conversations you are a part of. 2.0.5 Help Files Along the bottom of every. single. page. there is the “Help” button. GitHub has a great help system in place - if you ever have a question about GitHub, this should be your first point to search! Take some time now and look through the various help files, and see if any catch your eye. GitHub’s help files 2.0.6 Summary In this lesson we looked at GitHub and its interface. We took a tour of the website and its interface. We customized your profile to give people some more information on who you are. We made our very first repository by following the GitHub guide and explored the various options GitHub provides for exploring repositories. 2.0.7 Slides and video Automated Video Slides "],["creating-a-repository.html", "Chapter 3 Creating A Repository", " Chapter 3 Creating A Repository Now that you have learned about version control and the GitHub website, we will do some actual work with the GitHub website to create a new repository and set up your user profile. 3.0.1 What is a Repository? First let’s review what a repository is. A repository houses the entirety of a project. Imagine a filing cabinet. A repository for this project would be the filing cabinet itself. Inside the cabinet are various folders and files that make up the project. As you begin working on various projects, each one will likely have its own repository, and any work that you do will be housed in that repository. In the first part of this lesson, we will discuss how to create a repository using the GitHub website. 3.0.2 How Do I Create a GitHub Repository? 3.0.2.1 Step 1 First, navigate to the GitHub website: GitHub.com. Click the green button on the right hand side of the page that allows you create a new repository. Creating a new repository 3.0.2.2 Step 2 You will be taken to a new page where you can set up information about this new repository. Most importantly, create a descriptive name for the repository that relates to your project. This will help you remember what repository holds your files for this project if you have many repositories or come back to the project at a later time. Including a description for your repository is optional. You have a choice to make your repository public or private. Public repositories are viewable by the public. Anyone can see what code you have used for this project. You can still control who can contribute to this particular repository, but the repository is open to being forked by other people who may want to build off of your work in their own repositories. Private repositories are not viewable by the public, and you can still control who can contribute to this particular repository. It is generally a nice choice to make a repository public to share your work with others, but if you are working with sensitive information, it would be best to make the repository private. Keep in mind that you can have private repositories on GitHub only if you are a paid subscriber. You can leave the other options at their default settings. When you are satisfied with these settings, click the “Create repository” button at the bottom. Setting up a new repository And you’re done! You will be taken to a page that looks as below. This page contains information about the commands that will be useful when adding files to your repository later on. We will cover the use of these commands from RStudio Cloud in subsequent lessons. Landing page 3.0.3 Adding a README File If you click on the link labeled README indicated in the picture below, you can add a README file to your currently empty repository. The README file is the first thing someone sees when they navigate to the page for your repository. It is useful for providing an overview for what is contained within it. Creating a README When you click on that link, you will be taken to a page pictured below where you can edit the text of this file and preview what it will look like on the GitHub website. It has been automatically filled in with the title of our repository and the optional description we entered previously. Feel free to add additional description. The README file is a markdown document so you will have to use the markdown syntax you learned in the last course to edit this document. Editing a README When you are finished editing your README file, scroll to the bottom of the page to commit your changes. Here, GitHub automatically suggests that “Create README” is your commit messages. As this is informative of what you have done, you do not need to add additional text; however, you’re welcome to make this commit message even more informative if you’d like. Committing changes Click the “Commit new file button” to add this README to your repository. You will be taken to the homepage for your repository, as pictured below. Repository homepage Congratulations! You have created and set up your first repository! 3.0.4 The GitHub Guide GitHub also recognizes that this can be an overwhelming process for new users, and as such have developed a mini tutorial to get you started with GitHub. You can go through this guide to get further process setting up repositories on GitHub! 3.0.5 Slides and Video Automated Videos Slides "],["cloning-a-repository.html", "Chapter 4 Cloning A Repository", " Chapter 4 Cloning A Repository Now that you have learned how to create a GitHub repository, you will learn how to obtain a copy of that repository in a location that you use for writing code such as RStudio Cloud. This process is called “cloning” a repository from GitHub. 4.0.1 Step 1: Obtain the URL for the repository to clone Navigate to the GitHub webpage for your repository. This URL always has the form https://github.com/github_username/repository_name For example, in our last lesson, the URL for our repository is https://github.com/JaneEverydayDoe/first_project/. On this page, you will see a button on the right hand side that says “Clone or download”. When you click this, highlight the URL in the box, and copy it to the clipboard. Make sure it starts with “https” rather than “git@”. If you see “git@”, click the link in the top right corner of the box that says “Use HTTPS”. 4.0.2 Step 2: Use the RStudio interface to clone the repository In RStudio cloud, go to your workspace by clicking the appropriate button on the left side navigation bar. Click the New Project button and choose New Project from Git Repository Place the URL that you copied in Step 1 in the URL of your Git Repository box, and click OK. You will a Deploying Project progress screen, typically after a few seconds, the RStudio interface for your project will appear. Also note that in the bottom right hand corner of RStudio, in the Files pane, you will have the files that are in your GitHub repository, now available in this RStudio cloud workspace. 4.0.3 Step 3: Set up GitHub Credentials In order to be able to access everything in your GitHub repository from RStudio cloud, you will need to set up GitHub credentials. You should only need to do this once per project. In your RStudio interface, make sure that you are in the Console tab. Now use the command below to install the package usethis. Copy and paste it in the Console window and click Enter on your keyboard. This package will help us manage our GitHub credentials from RStudio more easily. install.packages(&quot;usethis&quot;) This will take a minute or so to install. Remember that red text doesn’t mean an error necessarily. Now to use this package, we need to attach its library using the following command: library(&quot;usethis&quot;) RStudio and GitHub require you make a special fancy password to use as credentials called a GitHub Personal Access Token (sometimes abbreviated as a “PAT”). To create a ‘PAT’ from RStudio we can run this handy command: usethis::create_github_token() Running this command will open up a window in your GitHub that will ask you for your password. Login to GitHub as you normally would. This will open up a page in GitHub for creating a New personal access token. Underneath the Note put something that reminds you what this PAT is for. Something like RStudioCloud Access. (Note that each PAT you make needs its own unique Note though). Underneath the Select scopes section you don’t need to do anything, usethis package already chose the permissions we need. Scroll all the way down on this page and click Generate Token. You’ve created your first PAT! Do not close this window, keep it handy for now. Note that in the image below we blocked out our PAT, but yours will show a jumble of letters and numbers Return back to your RStudio Cloud project while keeping your PAT handy. In the Console window, run this command: gitcreds::gitcreds_set() It will ask you to ? Enter password or token. Copy your PAT and paste it into the command window and press Enter. After you enter your PAT here you should get a message like: -&gt; Adding new credentials... -&gt; Removing credetials from cache... -&gt; Done. You are now free to close that GitHub PAT window. Note that you will want to be very careful with your PAT. Do not share it or put it anywhere that others could see it or access it! Now we also need to add your username and email to the RStudio GitHub credentials by running a command like below. But replace the example username and email with what corresponds to your GitHub account. use_git_config(user.name = &quot;Jane&quot;, user.email = &quot;jane@example.org&quot;) Run this in the Console tab as well and click Enter. Now to double check that everything is set, we can run this command to have the usethis package echo back our credentials: git_sitrep() It will give you output that looks similar to this: (but note it will have your own user name, and repository name and etc.) Git config (global) • Name: &#39;Jane&#39; • Email: &#39;jane@example.org&#39; • Global (user-level) gitignore file: &lt;unset&gt; • Vaccinated: FALSE ℹ See `?git_vaccinate` to learn more • Default Git protocol: &#39;https&#39; • Default initial branch name: &lt;unset&gt; GitHub • Default GitHub host: &#39;https://github.com&#39; • Personal access token for &#39;https://github.com&#39;: &#39;&lt;discovered&gt;&#39; • GitHub user: &#39;Jane&#39; • Token scopes: &#39;gist, repo, user, workflow&#39; • Email(s): &#39;jane@example.org (primary)&#39; ✖ Local Git user&#39;s email (&#39;jane@example.org&#39;) doesn&#39;t appear to be registered with GitHub. Git repo for current project • Active usethis project: &#39;/cloud/project&#39; • Default branch: &#39;master&#39; • Current local branch -&gt; remote tracking branch: &#39;master&#39; -&gt; &#39;origin/master&#39; GitHub remote configuration • Type = &#39;theirs&#39; • Host = &#39;https://github.com&#39; • Config supports a pull request = FALSE • origin = &#39;JaneEverydayDoe/first_project&#39; (can not push) • upstream = &lt;not configured&gt; • Desc = The only configured GitHub remote is &#39;origin&#39;, which you cannot push to. If your goal is to make a pull request, you must fork-and-clone. `usethis::create_from_github()` can do this. Read more about the GitHub remote configurations that usethis supports at: &#39;https://happygitwithr.com/common-remote-setups.html&#39; You should see that Name, email have your credentials set as well as a Personal access token for 'https://github.com': '&lt;discovered&gt;' You can run git_sitrep() at anytime to see what your credentials and settings are. Yay! Now you should be able to use GitHub from RStudioCloud! 4.0.4 Directory/Folder Organization A big part of staying organized with your files is understanding how folders in your project are organized. Also important is the concept of a working directory. Whenever you are working in R or the Terminal, files are housed in some folder. This folder is called the working directory. Knowing this is important so that you know how to specify paths to other important folders in your project. We can see what the current working directory is in a number of ways. In the image below, we can see from the Terminal prompt that the working directory is /cloud/project. We can also see this in the Files pane. We see that the first level folder is cloud and that the second level folder is project. Congratulations! You have cloned your first repository! 4.0.5 Slides and Video Automated Videos Slides "],["pushing-and-pulling-changes.html", "Chapter 5 Pushing and Pulling Changes", " Chapter 5 Pushing and Pulling Changes Now that you have learned how to create a repository and clone it, it’s time to start using repositories to manage projects and work with collaborators. In this lesson you will learn about new git commands for publishing changes so that others can see them. You will also learn a git command for incorporating changes made by others in your local copy of a repository. 5.0.0.1 Get Status A helpful git command is git status. If you type this in the terminal and press “enter” on your keyboard, the files that have been modified or added since you last updated changes on GitHub will be displayed. However, before working with the git commands that will track and publish our changes, we need to change the working directory in the Terminal to be the first_project folder. We can do this with the cd command. Using the command cd PATH changes the working directory to the folder specified by PATH. For example, if the first_project folder contained a folder called analysis, we could set our Terminal working directory to this folder with cd first_project/analysis. To continue change the working directory by typing the command cd first_project in the prompt. Changing the working directory in the Terminal As you’ve just cloned a repository in the last lesson, there are no changes yet. You can type git status at any time in the Terminal to see what files have been modified locally that are not yet on GitHub. This is particularly helpful when you want to decide which files to stage, which is discussed in more detail later in this lesson. git status output 5.0.1 Pushing Over the course of working on a project, you will be creating a number of files containing code, results, documentation, or other information. How do you add these files to the Git version control system and make this information available to the public? In the first part of this lesson, you will learn about three git commands that allow you to do this: add, commit, and push. 5.0.1.1 Create a File Let’s start by creating a file within the project. Below we’ve created a text file containing a list of tasks. This is saved as tasks.txt within the first_project folder. This is the repository that we cloned in the previous lesson. Creating a file in our project repository 5.0.1.2 Staging and Committing Now that we have added a file to this repository, let’s put it under version control and publish these changes. First we need to move to the Terminal pane. Recall that the text at the beginning of the line is called the prompt. The Terminal prompt shows the current working directory within the Terminal. Initially, the working directory is the /cloud/project folder. We can see the same information by entering the pwd command. We can use the ls command to list the files and folders that are in the current working directory. If you haven’t previously added any files or folders here, you’ll see that the first_project folder is the only thing present. We will first use the git add command to tell Git that the tasks.txt file is to be tracked for version control. The syntax for the add command is: git add file_or_folder1 file_or_folder2 This “stages” the the specified files or folders, adding them to the list of directories and files that should be added to GitHub. Any number of files and/or folders can be specified in this way. To add the tasks.txt file, we use git add tasks.txt While you only have a file or two to add at this point and typing them each individually is not much work, as you start work on larger projects and edit multiple files at a time, typing out each file you want to add individually will become a pain. To get around this, you can specify that you want to stage multiple files at once using the following syntax: git add . Here, a period has been added after git add. What this does is stage (add) new and modified files. However, this does not stage files that have been deleted. Alternatively, to add modified and deleted files but to not include new files, you would use the following syntax: git add -u To add all files, adding new, modified, and deleted files, you would use the following syntax: git add -A The final shortcut we’ll discuss for staging files is the ability to use the wildcard () character with git add. Here, wildcard character () followed by .csv specifies that you want to stage any file that has the file extension “.csv”. git add *.csv You could alternatively use git add *. However, if you remember back to the lesson on removing files, you were cautioned against ever using rm * because you can very easily but accidentally delete files you didn’t mean to delete. The same logic works here. git add * will add everything, including hidden files, and thus should be used with caution. Instead, use options discussed above to stage your files. git add summary table Now that we have let git know that which file should be tracked for version control, we will actually record those changes with git commit. The commit command takes the files that we added with add and updates the Git version history record with these changes. When we use the commit command we also supply a descriptive message about the changes that were made by specifying the -m option followed by the message in quotes. You can write anything as the message, however, since you may go back to your previous commits some day, it’s considered good practice to write a descriptive message that has some information about the nature of the changed you made. git commit -m &quot;Add task list&quot; Adding a file and committing changes 5.0.1.3 Verifying Your Identity On RStudio Cloud, you’ll have to verify who you are each time you try to make changes to a repository. You’ll know you have to do this when you try to git commit and you get an error that starts with: “Please tell me who you are,” followed with some suggestions about using git config. When this occurs, you’ll be prompted to type the following into the terminal: git config user.name &quot;UserName&quot; git config user.email &quot;email@domain.com&quot; To do this, you’ll first specify your username. To do this, if your GitHub username were JaneEveryayDoe you would type the following and then press enter: git config user.name &quot;JaneEverydayDoe&quot; If your email address connected to your GitHub account were “janeeverydaydoe@gmail.com”, you would then type the following and press enter: git config user.email &quot;email@domain.com&quot; Note: If you’re asked for your password, you should type in your GitHub password and hit Enter, but know that you will not actually see the characters show up on the screen as you type them. 5.0.1.4 Publishing changes (pushing) We are finally ready to publish our changes to a remote repository. We’ve been doing work in a local copy of the repository on RStudio Cloud. This personal copy is called a local repository. To make changes available to others, there needs to be an external version of the repository accessible by others. This is called a remote repository. Our remote repository is the one available on GitHub. To publish our changes, we use the git push command. Because we cloned this repository from GitHub, Git automatically knows that this is the remote repository. A local repository can have multiple remotes, and it is possible to push changes to a specified remote. We will not cover this here though. After you run git push, you will see some status text and you will be prompted for your GitHub username and password. After you enter these, the push will be complete. Pushing changes 5.0.2 Pulling While working on a project, we may have a collaborator working on files in the same repository. If they create and edit files in their own local repositories and push changes to our shared remote repository on GitHub, we will want to incorporate their changes into our files. We can do this with git pull. For example, a collaborator might have added an additional task to the tasks.txt file. Seeing on GitHub that a file has been edited When we run the git pull command, the changes present in the remote repository are incorporated into our local repository. So when we open the tasks.txt file, we will see the additional task. Pulling changes from the remote to our local repository 5.0.3 Practice To get more practice with these concepts, as we know they are not the easiest, we suggest you go practice at GitHub Learning Lab. Here you can practices your git commands and get feedback as to what you’ve done correctly and where you steered off course. It’s a great way to get better at using git commands before you move onto the quiz! 5.0.4 Slides and Video Automated Videos Slides "],["organization-with-issues-on-github.html", "Chapter 6 Organization with Issues on GitHub", " Chapter 6 Organization with Issues on GitHub We’ve covered the basics of how to set up a repository for a project and synchronize changes between local and remote versions of the repository. In this lesson, we will introduce a tool called Issues on GitHub that is useful for organization and communication within a project. 6.0.1 What are Issues? Issues are essentially a task system that come with GitHub repositories. They allow specification of a certain task or item to complete and have discussion threads, assigned workers, and labels. They are a convenient way to stay organized and communicate with others involved in or interested in your project. 6.0.2 Creating an Issue First navigate to the Issues tab on the main repository webpage. Navigating to the Issues tab Then click the green button that says “New issue.” Where to create a new issue On the resulting page, there are forms that allow you to type a concise description of the task and a more detailed description. This description could be used to elaborate specific steps that are needed to fulfill this task. There are also options on the right that allow you to assign GitHub users to work on this issue. On the right hand side, you can also assign labels to an issue. This can be useful if your project has many issues, and you later want to view only certain ones. Creating a new issue After you create this issue, you will be taken to the webpage for your issue which contains a discussion thread. You can use this to communicate with others about the status of this task. When the task is complete, you can close the issue to mark it as resolved. Discussion thread for an issue Over the course of the project, you can come back to the Issues tab on your repository webpage to view the status of different tasks. Main board for all issues 6.0.3 Slides and Video Automated Videos Slides "],["setting-up-a-project-on-github.html", "Chapter 7 Setting Up A Project on GitHub", " Chapter 7 Setting Up A Project on GitHub Having learned how to organize a data science projects in the last course and how to navigate GitHub and git commands in this course, in this lesson, we’ll put all of this together and walk through setting up an example project and pushing the content to GitHub. 7.0.1 Setting up a GitHub Repository First things first, we need to create a new repository. We’ll do this as discussed in the “Creating A Repository Lesson,” by going to GitHub, logging in to your account, and creating a new repository. Create a new repository You can also create a new repository by clicking on the plus sign in the top right corner of GitHub homepage and clicking on “New repository”. Second way of creating a new repository On the page that follows, type the repository name. Choose the name my_first_project, add a description if you wish (always recommended), make it public, and choose to initialize with a README file. At the end click on the button Create repository. Add repository information The next step is to clone this repository into RStudio Cloud but as you may remember, we first need the url to this repository we just created. On the repository page, click on Clone or download and copy the link address. Make sure the address starts with https rather than git. If it starts with git, click on Use HTTPS on the corner of the small window to have the link starting with https. Repository link 7.0.2 Creating a New Project from a GitHub Repository Ok, now that we have everything set up on the GitHub end, Go to RStudio Cloud and login with your account. When you’re redirected to your Projects page, Next to the New Project button, click on the drop down button and then click on New Project from Git Repo. Create new project from Git repo on RStudio Cloud On the popup window, paste the repository url that you just copied and click Ok. Enter repository url This will automatically clone the remote repository and create a new project on RStudio Cloud. Note that the repository is still unnamed so you may want to change the name to something else. If you click on the README file under Files, you will see that the README file contains the description you added on the GitHub website. All the files in the remote repository are cloned in RStudio Cloud Start editing the README file. Specifically, replace the content with the following lines. # This is the README file for my_first_project The folders in this project are: * _data_ - is the folder where you will put all the data you have collected or been given to analyze. * _figures_ - is where you will put plots, data pictures, and other images you have created to show data to other people. * _code_ - is where you will create code files for collecting, cleaning up, or analyzing data. * _products_ - this is the place where you will place any reports, presentations, or products you create for sharing with other people. 7.0.3 Pushing Local Changes to the Remote Repository in RStudio Cloud Now, it’s time to stage, commit, and push the changes we made to the remote repository. As we’ve seen we should follow the steps here. Type the following commands in the terminal one by one. Note that here we’re using git add . which means we are tracking changes in all new and modified files and folders in the project. git add . git commit -m &quot;changed readme file&quot; git push Once you enter git push, you will see a prompt asking you for your repository user name and then password. Enter those correctly and voila, you will see something similar to this which means that all the changes are pushed to the remote repository. Counting objects: 3, done. Delta compression using up to 16 threads. Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 338 bytes | 0 bytes/s, done. Total 3 (delta 1), reused 0 (delta 0) remote: Resolving deltas: 100% (1/1), completed with 1 local object. To https://github.com/JaneEverydayDoe/my_first_project.git e80844c..24fec16 master -&gt; master You should be able to see your changes on the repository on GitHub.com. Changes can be seen on the remote repository We have learned about the importance of organization and folder structure in data science projects. Let’s practice creating the main folders required in a data science project. As you may remember, these folders represent the four parts of any data science project: data, figures, code, and products. Let’s create them on RStudio Cloud. Data science project folders Now go ahead and further create the folder structure that we learned. An important note is that if you push the changed you created in the project to GitHub, you won’t see the folder structure that you created. Unfortunately, a folder structure won’t be pushed to GitHub unless the folders contain at least a file. So don’t worry. Once you populate this project with your data, code, figures, and writings and push them to GitHub you will see the folders your just created. data/ raw_data/ tidy_data/ code/ raw_code/ final_code/ figures/ exploratory_figures/ explanatory_figures/ products/ writing/ 7.0.4 Slides and Video Automated Videos Slides "],["pull-requests.html", "Chapter 8 Pull Requests", " Chapter 8 Pull Requests 8.0.1 What is a pull request As a reminder, there are two parts to the git and GitHub system. Git is focused on version control - basically keeping track of the different versions of all the files you are working on. You can track a git repo on just for yourself to make sure you always have your file history available to you. Git keeps track of your files GitHub is two things, first it is a way to back up and store all of your projects on the Internet. GitHub stores and backs up your files online But, it is also a social network for coders. You can use GitHub to contribute to other people’s projects and get feedback on your projects as well. GitHub also lets you work with others In an earlier lesson we learned about issues. Issues are comments that you can make on either one of your own repos or on someone else’s repos. Pull requests are a different kind of interaction that involve making a change directly to someone’s code. First you would fork the repo to make your own copy. Forking a repo means you can change the code Then you can send the owner of the repo a “request” to “pull” your change into their code. If they accept your pull request, then their code will be updated with your suggestion! You can send a request to have your code change pulled into theirs Pull requests are a great way to contribute to projects that are being worked on by more than one person. This may be because you are working directly with a team and you all need to edit a document. Or it may be because you see someone else’s project and want to make a suggestion. This is in fact one of the best ways to start to introduce yourself to the R community on GitHub. Find a project or a repo where you see something small you can help with - even if it is just fixing a typo or adding a comments - and send them a pull request. Pull requests are a great way to start contributing to the coding community online 8.0.2 Forking a repo Now let’s talk about how to make a pull request. The first thing that you will need to do is to create a “fork” of the repository you want to edit. This is a little different than “cloning” which you learned about in an earlier lesson. When you clone a repository you are just getting a copy of the project on RStudio Cloud. You are not creating a new version that you can work on. Cloning a project just gets you a copy on RStudio Cloud When you fork a repo, something different happens. First a new repo is created under your account on GitHub. You can then clone that copy to your computer. Now when you make edits to the files on RStudio Cloud and push them, they will be pushed to your fork. Forking a repo makes a copy on GitHub that you can push and pull from Let’s try this out. We are going to make some changes to a repo and send a pull request. We will use https://github.com/jtleek/newproject as an example project to send a pull request to. The first step is to create a fork of this repository. To do this, go to the project webpage and click on Fork in the top right hand corner of the screen. We are going to fork the newproject repo from jtleek This may ask you where to fork the repository if you are on multiple teams. Select your main account and wait while the repository is forked. Select your main account to fork to You will see now that you have your own version of the newproject repository on your GitHub profile and you will be able to see where the repository was forked from right under the repository name on the upper left. You now have a forked copy of the repo Now that you have a copy of this repository on your GitHub account, you can clone it to RStudio Cloud as we learned about in a previous lesson. You can clone it by navigating to the terminal in your RStudio Cloud account and typing the command git clone https://github.com/your_username/newproject.git Go to RStudio Cloud and find the terminal in your project, and use the git clone command to get your fork where you replace your_username with your GitHub username. This should create a folder on your RStudio Cloud account called newproject. You may have to enter your username and password. You may have to use your username and password to clone Now you have successfully “forked” and “cloned” the newproject repository. Once you have cloned, you have your forked repo on RStudio Cloud 8.0.3 Making edits The next step is to make some edits to one or more of the files. This could be as simple as fixing a typo or as complicated as adding a whole new function. For now, let’s open up the file myfile.Rmd and make an edit. For example, we could change the line of code that reads: summary(cars) to a line that loads the dplyr package and uses the glimpse function to look at the data set. library(dplyr) glimpse(cars) After making this edit you can save the file. Now we are ready to start the process of sending a pull request. Edit myfile.Rmd and save the file 8.0.4 Pushing your changes to your fork Remember that when we forked the repo from jtleek’s GitHub account, we got a new repo under your account. The first step in sending a pull request is to commit and push the edits to your fork (or copy) of the repo. To do this, navigate to the terminal and make sure that you are in the right folder. To do this you can use the Unix commands pwd and cd to make sure you are in the right place. When you type the command: pwd you should hopefully see that you are in the folder for newproject. If you are not, then you will need to use the cd command to make sure you are in that folder. Use pwd and cd to get into the newproject folder To start a pull request, you need to make sure you use git add to add any new files you might have changed or deleted. git add -A This will make sure that git is now monitoring those files you might have added. Use add to tell Git to monitor your file Next you can commit your changes with a message describing what you did. Since we are going to be sending a pull request to someone else, it is a good idea to have a very clear commit message. So for example we could use the git commit command like this. git commit -m &quot;I edited myfile.Rmd to use glimpse() to summarize the cars data&quot; Use git commit to save a version of your files on RStudio Cloud Now you will have saved the file on RStudio Cloud, but you still need to make the change to your fork of the repo. To do this we need to use the git push command. git push Use push to send the files to your forked repo You might be asked to input your username and password for GitHub to make this push. But, once it has happened you should be able to go to your forked version of the repository at https://github.com/your_username/newproject/ and see the changes in the file myfile.Rmd on the GitHub website. When you have successfully pushed the files appear on your forked repo on GitHub 8.0.5 Sending a pull request Now you have successfully forked jtleek’s newproject repo, cloned it to RStudio Cloud and made some edits. You have added, committed, and pushed those changes to your own fork. The next step is to send a pull request to the user who created the original repo. To do this you should go to the website with your fork. Now you can click on the “Pull requests” tab for your repo. Click on the pull requests tab for your forked repo Then click on “New Pull Request”. If there have been no changes made to the original repo from jtleek other than yours you should see that your pull request is “able to be merged” in green. You will also see a “diff” which is all of the files and changes to those files that you have made. You can then click on “Create Pull Request” to send the change to jtleek for him to review. Check to see if the pull request is able to merge and click Create Pull request You will be shown a screen where you can describe your pull request with a title and with a description of what you did. It is a good idea to put a pretty complete description of what you did - this will be the only description that jtleek can use to decide whether to merge the changes to his repo or not. Describe your changes for the original owner of the repo so they know what you did. When you have finished typing your message click “Create Pull Request” to send the pull request to jtleek. Click “Create Pull Request” to send the changes to jtleek. Now that you have created the pull request you can go to the original repo https://github.com/jtleek/newproject and click on the pull requests tab. You will be able to find your pull request among those that are open. In this case, since this is a repo that is used as an example for a MOOC there may be many open pull requests. On the original repo your pull request appears The author of the original repo can then either accept your change, or they can ask you questions about your pull request just below the place where they can decide whether to merge the change. You can communicate with the author using the Write box. Once they click on “Merge pull request” your changes will automatically be incorporated into their code. Congratulations you have helped someone fix their code and made a new friend on GitHub! Once the original author logs in they can merge your pull request if they want. 8.0.6 When it gets more complicated This is the easiest case of a pull request. The author of the original repo hasn’t made any changes to the files that conflict with the changes that you made. In general, it is much nicer for the owner of the repo to accept your pull request if they don’t have to fix any conflicts. So when you decide to make a change to someone’s code, it is a good idea to make sure you make a fresh fork with all the latest changes in their code. Then clone, edit, push, and send your pull request in a timely way. This should ensure that there are no conflicts when you send the pull request to the original author. Sometimes it is more difficult than that since you may be editing a repo that is in active development or is being edited by multiple people. In this case, you will need to keep your forked version of the repo up to date with the original version. GitHub has instructions for keeping your fork up to date and Jenny Bryan’s book Happy Git and GitHub for the useR also has a section on forking that may be useful when encountering these more complicated scenarios. GitHub has instructions for syncing a fork. 8.0.7 Summary This lesson covered how to collaborate on someone else’s code. In the process of discussing what a pull request is and walking through the steps of submitting a pull request, this lesson has reviewed a number of git commands including git pull, git push, and git commit. And, by submitting good pull requests in a timely fashion that help authors fix bugs in their code or typos in their documentation, you’ll be contributing to the R community! 8.0.8 Slides and Video Automated Videos Slides "],["version-control-help.html", "Chapter 9 Version Control Help", " Chapter 9 Version Control Help We’ve previously discussed how to get help generally (Google!) and in the future we’ll cover how to get help when you’re stuck coding in R; however, at this point it’s important to briefly discuss getting help when working with a version control system like GitHub. In the lessons in this course we’ve covered a number of important git commands, such as clone, status, pull, push, add, commit, etc. As you’re learning these commands and getting more comfortable with how to use them, you will certainly make mistakes. There are ways using git commands to revert back to previous versions (previous commits) of your GitHub repo and to fix merge conflicts (which often arise when multiple people are editing the same file at the same time). However, the ways in which you will make mistakes using git commands is not necessarily predictable. Because of this, we aren’t going to walk you through any “this is how you fix that common error” tutorials. Instead, we’re going to walk you through how to find the answer to the mistake you made yourself. While there are many ways to make a mistake on GitHub, take solace in the fact that you probably aren’t the first person to have made this mistake. This means that the answer to your error is likely to be found on the Internet! 9.0.1 Google for git help When you’re getting merge conflicts or errors when trying to run git commands in the Terminal, Googling the specific error message you’re getting can be very helpful. For example, if you’re getting a merge conflict error on GitHub, you may want to Google “git merge conflict help” to start you on your path to git merge conflict recovery. Google: “git merge conflict help” Or, if you’ve changed some documents, realized you didn’t actually want to make those changes, and want to revert back to a previous commit, you may google “git revert to previous commit” Google: “git revert to previous commit” In both of these cases, links that will be helpful in figuring out your issue are provided and what git commands you’ll want to try to recover from your mistake. By clicking on the links and following the instructions provided, you’ll often be able to solve your problem. However, some links will be more helpful than others. Help from places like Stack Overflow (www.stackoverflow.com) and help.github.com are good places to start. Additionally, as you practice and get more comfortable with git and GitHub you’ll make fewer mistakes and understand the process even better! 9.0.2 Burn it Down That all said, while sometimes Googling can be incredibly helpful, it’s important to remember that git and GitHub are tackling incredibly difficult problems (version control and tracking changes is no simple task!). This means that while trying to track all your changes and use git commands, you may run into trouble that Googling won’t help you solve. For times when you’ve made a lot of changes and are struggling to even track down what it is you’ve done and what you want the GitHub repository to look like when it’s all better. For these cases, it’s best to just do what is referred to as “burning it all down,” the process of which is described in a chapter of Jenny Bryan’s Happy Git with R and captured perfectly in this xkcd cartoon. Briefly here, for those worst-case scenarios when your GitHub repository and your local copy just cannot get to a happy place where you can push and pull with ease, you’ll likely just want to: move the files and directories from your local copy to a safe space that is separate from the directory you’ve cloned from GitHub. It’s best at this point to rename the directory. Once your files are in a safe (and different) directory, you’ll want to clone the repo from GitHub again (which takes the last happy copy from GitHub and makes it available to you locally). You are now back to a safe state where you can easily push and pull. You’re then ready to copy all the files from the safe directory back to this newly-cloned and happy repository. After the files have been returned, you’ll want to stage (git add), commit, and push your files back to GitHub. While this is not a particularly elegant solution, it works in your most desperate times of need! Practice these steps now so that you know how to use them when you actually need them. And trust me, if you’re new to git and GitHub, you’ll probably need them. 9.0.3 Summary This lesson is intentionally short. There are lots of ways that git and GitHub will seem frustrating as you learn to use them. Remember that this is because git and GitHub are tackling difficult problems. When you run into issues with git and GitHub, the best thing is to look to the Internet for help. Read the answers online, think about whether they’ll work for the issue you’re having, and then give them a try. As you get more comfortable working with git for version control, you’ll run into fewer and fewer of these problems. However, in the meantime, use the Internet for help, and when all else fails, just burn it all down. 9.0.4 Additional Resources Happy Git and GitHub for the useR, by Jenny Bryan GitHub Help 9.0.5 Slides and Video Automated Videos Slides "],["about-the-authors.html", "About the Authors", " About the Authors These credits are based on our course contributors table guidelines.     Credits Names Pedagogy Lead Content Instructor(s) FirstName LastName Lecturer(s) (include chapter name/link in parentheses if only for specific chapters) - make new line if more than one chapter involved Delivered the course in some way - video or audio Content Author(s) (include chapter name/link in parentheses if only for specific chapters) - make new line if more than one chapter involved If any other authors besides lead instructor Content Contributor(s) (include section name/link in parentheses) - make new line if more than one section involved Wrote less than a chapter Content Editor(s)/Reviewer(s) Checked your content Content Director(s) Helped guide the content direction Content Consultants (include chapter name/link in parentheses or word “General”) - make new line if more than one chapter involved Gave high level advice on content Acknowledgments Gave small assistance to content but not to the level of consulting Production Content Publisher(s) Helped with publishing platform Content Publishing Reviewer(s) Reviewed overall content and aesthetics on publishing platform Technical Course Publishing Engineer(s) Helped with the code for the technical aspects related to the specific course generation Template Publishing Engineers Candace Savonen, Carrie Wright Publishing Maintenance Engineer Candace Savonen Technical Publishing Stylists Carrie Wright, Candace Savonen Package Developers (ottrpal) John Muschelli, Candace Savonen, Carrie Wright Art and Design Illustrator(s) Created graphics for the course Figure Artist(s) Created figures/plots for course Videographer(s) Filmed videos Videography Editor(s) Edited film Audiographer(s) Recorded audio Audiography Editor(s) Edited audio recordings Funding Funder(s) Institution/individual who funded course including grant number Funding Staff Staff members who help with funding   ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 4.0.2 (2020-06-22) ## os Ubuntu 20.04.3 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Etc/UTC ## date 2023-03-20 ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date lib source ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.0.3) ## bookdown 0.24 2022-02-15 [1] Github (rstudio/bookdown@88bc4ea) ## callr 3.4.4 2020-09-07 [1] RSPM (R 4.0.2) ## cli 2.0.2 2020-02-28 [1] RSPM (R 4.0.0) ## crayon 1.3.4 2017-09-16 [1] RSPM (R 4.0.0) ## desc 1.2.0 2018-05-01 [1] RSPM (R 4.0.3) ## devtools 2.3.2 2020-09-18 [1] RSPM (R 4.0.3) ## digest 0.6.25 2020-02-23 [1] RSPM (R 4.0.0) ## ellipsis 0.3.1 2020-05-15 [1] RSPM (R 4.0.3) ## evaluate 0.14 2019-05-28 [1] RSPM (R 4.0.3) ## fansi 0.4.1 2020-01-08 [1] RSPM (R 4.0.0) ## fs 1.5.0 2020-07-31 [1] RSPM (R 4.0.3) ## glue 1.6.1 2022-01-22 [1] CRAN (R 4.0.2) ## hms 0.5.3 2020-01-08 [1] RSPM (R 4.0.0) ## htmltools 0.5.0 2020-06-16 [1] RSPM (R 4.0.1) ## jquerylib 0.1.4 2021-04-26 [1] CRAN (R 4.0.2) ## knitr 1.33 2022-02-15 [1] Github (yihui/knitr@a1052d1) ## lifecycle 1.0.0 2021-02-15 [1] CRAN (R 4.0.2) ## magrittr 2.0.2 2022-01-26 [1] CRAN (R 4.0.2) ## memoise 1.1.0 2017-04-21 [1] RSPM (R 4.0.0) ## ottrpal 0.1.2 2022-02-15 [1] Github (jhudsl/ottrpal@1018848) ## pillar 1.4.6 2020-07-10 [1] RSPM (R 4.0.2) ## pkgbuild 1.1.0 2020-07-13 [1] RSPM (R 4.0.2) ## pkgconfig 2.0.3 2019-09-22 [1] RSPM (R 4.0.3) ## pkgload 1.1.0 2020-05-29 [1] RSPM (R 4.0.3) ## prettyunits 1.1.1 2020-01-24 [1] RSPM (R 4.0.3) ## processx 3.4.4 2020-09-03 [1] RSPM (R 4.0.2) ## ps 1.3.4 2020-08-11 [1] RSPM (R 4.0.2) ## purrr 0.3.4 2020-04-17 [1] RSPM (R 4.0.3) ## R6 2.4.1 2019-11-12 [1] RSPM (R 4.0.0) ## readr 1.4.0 2020-10-05 [1] RSPM (R 4.0.2) ## remotes 2.2.0 2020-07-21 [1] RSPM (R 4.0.3) ## rlang 0.4.10 2022-02-15 [1] Github (r-lib/rlang@f0c9be5) ## rmarkdown 2.10 2022-02-15 [1] Github (rstudio/rmarkdown@02d3c25) ## rprojroot 2.0.2 2020-11-15 [1] CRAN (R 4.0.2) ## sessioninfo 1.1.1 2018-11-05 [1] RSPM (R 4.0.3) ## stringi 1.5.3 2020-09-09 [1] RSPM (R 4.0.3) ## stringr 1.4.0 2019-02-10 [1] RSPM (R 4.0.3) ## testthat 3.0.1 2022-02-15 [1] Github (R-lib/testthat@e99155a) ## tibble 3.0.3 2020-07-10 [1] RSPM (R 4.0.2) ## usethis 2.1.5.9000 2022-02-15 [1] Github (r-lib/usethis@57b109a) ## vctrs 0.3.4 2020-08-29 [1] RSPM (R 4.0.2) ## withr 2.3.0 2020-09-22 [1] RSPM (R 4.0.2) ## xfun 0.26 2022-02-15 [1] Github (yihui/xfun@74c2a66) ## yaml 2.2.1 2020-02-01 [1] RSPM (R 4.0.3) ## ## [1] /usr/local/lib/R/site-library ## [2] /usr/local/lib/R/library "],["references.html", "Chapter 10 References", " Chapter 10 References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
